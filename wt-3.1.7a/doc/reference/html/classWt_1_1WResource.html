<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>Wt: Wt::WResource Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javaScript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body onload='searchBox.OnSelectItem(0);'>
<!-- Generated by Doxygen 1.7.2 -->
<script type="text/javascript"><!--
var searchBox = new SearchBox("searchBox", "search",false,'Search');
--></script>
<div class="navigation" id="top">
  <div class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li id="searchli">
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="hierarchy.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
  <div class="navpath">
    <ul>
      <li><a class="el" href="namespaceWt.html">Wt</a>      </li>
      <li><a class="el" href="classWt_1_1WResource.html">WResource</a>      </li>
    </ul>
  </div>
</div>
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pro-methods">Protected Member Functions</a>  </div>
  <div class="headertitle">
<h1>Wt::WResource Class Reference</h1>  </div>
</div>
<div class="contents">
<!-- doxytag: class="Wt::WResource" --><!-- doxytag: inherits="Wt::WObject" -->
<p>An object which can be rendered in the HTTP protocol.  
<a href="#_details">More...</a></p>

<p><code>#include &lt;Wt/WResource&gt;</code></p>
<!-- startSectionHeader --><div class="dynheader">
Inheritance diagram for Wt::WResource:<!-- endSectionHeader --></div>
<!-- startSectionSummary --><!-- endSectionSummary --><!-- startSectionContent --><div class="dyncontent">
<div class="center"><img src="classWt_1_1WResource__inherit__graph.png" border="0" usemap="#Wt_1_1WResource_inherit__map" alt="Inheritance graph"/></div>
<map name="Wt_1_1WResource_inherit__map" id="Wt_1_1WResource_inherit__map">
<area shape="rect" href="classWt_1_1Ext_1_1DataStore.html" title="A resource that serializes data from a data model." alt="" coords="329,5,468,32"/><area shape="rect" href="classWt_1_1WFileResource.html" title="A resource which streams data from a local file." alt="" coords="332,56,465,83"/><area shape="rect" href="classWt_1_1WMemoryResource.html" title="A resource which streams data from memory." alt="" coords="316,107,481,133"/><area shape="rect" href="classWt_1_1WPdfImage.html" title="A paint device for rendering to a PDF." alt="" coords="341,157,456,184"/><area shape="rect" href="classWt_1_1WRasterImage.html" title="A paint device for rendering to a raster image." alt="" coords="331,208,467,235"/><area shape="rect" href="classWt_1_1WSvgImage.html" title="A paint device for rendering using Scalable Vector Graphics (SVG)." alt="" coords="339,259,459,285"/><area shape="rect" href="classWt_1_1WObject.html" title="A base class for objects that participate in the signal/slot system." alt="" coords="7,132,103,159"/></map>
<center><span class="legend">[<a href="graph_legend.html">legend</a>]</span></center><!-- endSectionContent --></div>

<p><a href="classWt_1_1WResource-members.html">List of all members.</a></p>
<table class="memberdecls">
<tr><td colspan="2"><h2><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ab4a2f71811a597a3603b039968dcb6d7"></a><!-- doxytag: member="Wt::WResource::WResource" ref="ab4a2f71811a597a3603b039968dcb6d7" args="(WObject *parent=0)" -->
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classWt_1_1WResource.html#ab4a2f71811a597a3603b039968dcb6d7">WResource</a> (<a class="el" href="classWt_1_1WObject.html">WObject</a> *parent=0)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a new resource. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classWt_1_1WResource.html#a776c19c9bbc95330941744cd129bc01a">~WResource</a> ()</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Destroys the resource.  <a href="#a776c19c9bbc95330941744cd129bc01a"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classWt_1_1WResource.html#a8f2c3c2aa013cebecd73398dadc3d6d0">suggestFileName</a> (const std::string &amp;name)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Suggests a filename to the user for the data streamed by this resource.  <a href="#a8f2c3c2aa013cebecd73398dadc3d6d0"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">const std::string &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classWt_1_1WResource.html#a966ece2e5a3e39d861e156ed0151402e">suggestedFileName</a> () const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the suggested file name.  <a href="#a966ece2e5a3e39d861e156ed0151402e"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classWt_1_1WResource.html#a9394f6c2ff6cadf8d1076ec52c5e909a">setChanged</a> ()</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Generates a new URL for this resource and emits the changed signal.  <a href="#a9394f6c2ff6cadf8d1076ec52c5e909a"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classWt_1_1WResource.html#a06bb9dbe3ae195c320cfed7b062d448a">setInternalPath</a> (const std::string &amp;path)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets an internal path for this resource.  <a href="#a06bb9dbe3ae195c320cfed7b062d448a"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classWt_1_1WResource.html#aca0470f44682d5b785045269235a23b0">internalPath</a> () const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the internal path.  <a href="#aca0470f44682d5b785045269235a23b0"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">const std::string &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classWt_1_1WResource.html#a5060efcabde5f793c9d44c5ca557417d">generateUrl</a> ()</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Generates an URL for this resource.  <a href="#a5060efcabde5f793c9d44c5ca557417d"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">const std::string &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classWt_1_1WResource.html#a11169bf885f297f6f2ebbc1789aeded2">url</a> () const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the current URL for this resource.  <a href="#a11169bf885f297f6f2ebbc1789aeded2"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classWt_1_1Signal.html">Signal</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classWt_1_1WResource.html#a1527418354a584790c372e86a40c6027">dataChanged</a> ()</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classWt_1_1Signal.html" title="A signal that propagates events to listeners.">Signal</a> emitted when the data presented in this resource has changed.  <a href="#a1527418354a584790c372e86a40c6027"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classWt_1_1WResource.html#ae0b96cdd80b982c74adb9a762c77d479">setUploadProgress</a> (bool enabled)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Indicate interest in upload progress.  <a href="#ae0b96cdd80b982c74adb9a762c77d479"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classWt_1_1Signal.html">Signal</a>&lt; ::uint64_t,::uint64_t &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classWt_1_1WResource.html#a37f002b4919486e057469b92d70c755d">dataReceived</a> ()</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classWt_1_1Signal.html" title="A signal that propagates events to listeners.">Signal</a> emitted when data has been received for this resource.  <a href="#a37f002b4919486e057469b92d70c755d"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classWt_1_1WResource.html#ad8bbe65a888cc43e0d356f18509b9a0f">write</a> (std::ostream &amp;out, const <a class="el" href="namespaceWt_1_1Http.html#a3420f95c8bfecf3d46e65920c765345a">Http::ParameterMap</a> &amp;parameters=<a class="el" href="namespaceWt_1_1Http.html#a3420f95c8bfecf3d46e65920c765345a">Http::ParameterMap</a>(), const <a class="el" href="namespaceWt_1_1Http.html#a90602329029048d738daae9ba63e059a">Http::UploadedFileMap</a> &amp;files=<a class="el" href="namespaceWt_1_1Http.html#a90602329029048d738daae9ba63e059a">Http::UploadedFileMap</a>())</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Stream the resource to a stream.  <a href="#ad8bbe65a888cc43e0d356f18509b9a0f"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classWt_1_1WResource.html#a3a740f8cc29e2e6e4e58defc9c88b8b6">handleRequest</a> (const <a class="el" href="classWt_1_1Http_1_1Request.html">Http::Request</a> &amp;request, <a class="el" href="classWt_1_1Http_1_1Response.html">Http::Response</a> &amp;response)=0</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Handles a request.  <a href="#a3a740f8cc29e2e6e4e58defc9c88b8b6"></a><br/></td></tr>
<tr><td colspan="2"><h2><a name="pro-methods"></a>
Protected Member Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classWt_1_1WResource.html#a24f65859427f54012fef2fa9da14870d">beingDeleted</a> ()</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Prepares the resource for deletion.  <a href="#a24f65859427f54012fef2fa9da14870d"></a><br/></td></tr>
</table>
<hr/><a name="_details"></a><h2>Detailed Description</h2>
<p>An object which can be rendered in the HTTP protocol. </p>
<h3>Usage</h3>
<p>Besides the main page, other objects may be rendered as additional resources, for example documents or images. Classes such as <a class="el" href="classWt_1_1WAnchor.html" title="A widget that represents an HTML anchor (to link to other documents).">WAnchor</a> or <a class="el" href="classWt_1_1WImage.html" title="A widget that displays an image.">WImage</a> can use a resource instead of a URL to provide their contents. Whenever the resource has changed, you should call the <a class="el" href="classWt_1_1WResource.html#a9394f6c2ff6cadf8d1076ec52c5e909a" title="Generates a new URL for this resource and emits the changed signal.">setChanged()</a> method. <a class="el" href="classWt_1_1WResource.html#a9394f6c2ff6cadf8d1076ec52c5e909a" title="Generates a new URL for this resource and emits the changed signal.">setChanged()</a> will make sure that the browser will use a new version of the resource by generating a new URL, and emits the <a class="el" href="classWt_1_1WResource.html#a1527418354a584790c372e86a40c6027" title="Signal emitted when the data presented in this resource has changed.">dataChanged()</a> signal to make those that refer to the resource aware that they should update their references to the new URL.</p>
<p>You can help the browser to start a suitable helper application to handle the downloaded resource, or suggest to the user a suitable filename for saving the resource, by setting an appropriate file name using <a class="el" href="classWt_1_1WResource.html#a8f2c3c2aa013cebecd73398dadc3d6d0" title="Suggests a filename to the user for the data streamed by this resource.">suggestFileName()</a>.</p>
<p>To serve resources that you create on the fly, you need to specialize this class and implement <a class="el" href="classWt_1_1WResource.html#a3a740f8cc29e2e6e4e58defc9c88b8b6" title="Handles a request.">handleRequest()</a>.</p>
<p>Example for a custom resource implementation: </p>
<div class="fragment"><pre class="fragment"> <span class="keyword">class </span>MyResource : <span class="keyword">public</span> Wt::<a class="code" href="classWt_1_1WResource.html#ab4a2f71811a597a3603b039968dcb6d7" title="Creates a new resource.">WResource</a>
 {
 <span class="keyword">public</span>:
   MyResource(<a class="code" href="classWt_1_1WObject.html" title="A base class for objects that participate in the signal/slot system.">Wt::WObject</a> *parent = 0)
     : Wt::<a class="code" href="classWt_1_1WResource.html#ab4a2f71811a597a3603b039968dcb6d7" title="Creates a new resource.">WResource</a>(parent)
   {
     <a class="code" href="classWt_1_1WResource.html#a8f2c3c2aa013cebecd73398dadc3d6d0" title="Suggests a filename to the user for the data streamed by this resource.">suggestFileName</a>(<span class="stringliteral">&quot;data.txt&quot;</span>);
   }

   ~MyResource() {
     <a class="code" href="classWt_1_1WResource.html#a24f65859427f54012fef2fa9da14870d" title="Prepares the resource for deletion.">beingDeleted</a>(); <span class="comment">// see &quot;Concurrency issues&quot; below.</span>
   }

   <span class="keywordtype">void</span> <a class="code" href="classWt_1_1WResource.html#a3a740f8cc29e2e6e4e58defc9c88b8b6" title="Handles a request.">handleRequest</a>(<span class="keyword">const</span> <a class="code" href="classWt_1_1Http_1_1Request.html" title="An HTTP request.">Wt::Http::Request</a>&amp; request,
                      <a class="code" href="classWt_1_1Http_1_1Response.html" title="An HTTP response.">Wt::Http::Response</a>&amp; response) {
     response.<a class="code" href="classWt_1_1Http_1_1Response.html#a20dd49d512ffc0cf407f9dd39db30341" title="Set the content mime type.">setMimeType</a>(<span class="stringliteral">&quot;plain/text&quot;</span>);
     response.<a class="code" href="classWt_1_1Http_1_1Response.html#ae74ee0009e9ec4aa3d3f35e680a745de" title="Returns the stream for getting the response output.">out</a>() &lt;&lt; <span class="stringliteral">&quot;I am a text file.&quot;</span> &lt;&lt; std::endl;
   }
 };
</pre></div><h3>Concurrency issues</h3>
<p>Because of the nature of the web, a resource may be requested one time or multiple times at the discretion of the browser, and therefore your resource should in general not have any side-effects except for what is needed to render its own contents. Unlike event notifications to a Wt application, resource requests are not serialized, but are handled concurrently. You need to grab the application lock if you want to access or modify other widget state from within the resource. When deleting a resource, any pending request is cancelled first. For this mechanism to work you need to specialize the destructor and call <a class="el" href="classWt_1_1WResource.html#a24f65859427f54012fef2fa9da14870d" title="Prepares the resource for deletion.">beingDeleted()</a>. This method may safely be called multiple times (i.e. from within each destructor in the hierachy).</p>
<h3>Continuations for asynchronous I/O</h3>
<p>With respect to I/O, the current strategy is to cache the whole response first in a buffer and use async I/O to push the data to the client, in order to free the thread while waiting for I/O on a possibly slow link. You do not necessarily have to provide all output at once, instead you can obtain a <a class="el" href="classWt_1_1Http_1_1ResponseContinuation.html" title="A response continuation object.">Http::ResponseContinuation</a> object for a response, construct the response piecewise. A new request() will be made to continue the response.</p>
<p>Example for a custom resource implementation using continuations: </p>
<div class="fragment"><pre class="fragment"> <span class="keyword">class </span>MyResource : <span class="keyword">public</span> Wt::<a class="code" href="classWt_1_1WResource.html#ab4a2f71811a597a3603b039968dcb6d7" title="Creates a new resource.">WResource</a>
 {
 <span class="keyword">public</span>:
   MyResource(<span class="keywordtype">int</span> iterations, <a class="code" href="classWt_1_1WObject.html" title="A base class for objects that participate in the signal/slot system.">Wt::WObject</a> *parent = 0)
     : Wt::<a class="code" href="classWt_1_1WResource.html#ab4a2f71811a597a3603b039968dcb6d7" title="Creates a new resource.">WResource</a>(parent)
     : iterations_(iterations)
   {
     <a class="code" href="classWt_1_1WResource.html#a8f2c3c2aa013cebecd73398dadc3d6d0" title="Suggests a filename to the user for the data streamed by this resource.">suggestFileName</a>(<span class="stringliteral">&quot;data.txt&quot;</span>);
   }

   ~MyResource() {
     <a class="code" href="classWt_1_1WResource.html#a24f65859427f54012fef2fa9da14870d" title="Prepares the resource for deletion.">beingDeleted</a>();
   }

   <span class="keywordtype">void</span> <a class="code" href="classWt_1_1WResource.html#a3a740f8cc29e2e6e4e58defc9c88b8b6" title="Handles a request.">handleRequest</a>(<span class="keyword">const</span> <a class="code" href="classWt_1_1Http_1_1Request.html" title="An HTTP request.">Wt::Http::Request</a>&amp; request,
                      <span class="keyword">const</span> <a class="code" href="classWt_1_1Http_1_1Response.html" title="An HTTP response.">Wt::Http::Response</a>&amp; response) {
     <span class="comment">// see if this request is for a continuation:</span>
     <a class="code" href="classWt_1_1Http_1_1ResponseContinuation.html" title="A response continuation object.">Wt::Http::ResponseContinuation</a> *continuation = request.<a class="code" href="classWt_1_1Http_1_1Request.html#a2d4f88961a222be846460a8238823ae0" title="Returns a continuation object.">continuation</a>();

     <span class="comment">// calculate the current start</span>
     <span class="keywordtype">int</span> iteration = continuation ? boost::any_cast&lt;<span class="keywordtype">int</span>&gt;(continuation-&gt;<a class="code" href="classWt_1_1Http_1_1ResponseContinuation.html#a92a3eb825c3df18ba5a6788315b8757b" title="Return data associated with the continuation.">data</a>()) : 0;
     <span class="keywordflow">if</span> (iteration == 0)
       response.<a class="code" href="classWt_1_1Http_1_1Response.html#a20dd49d512ffc0cf407f9dd39db30341" title="Set the content mime type.">setMimeType</a>(<span class="stringliteral">&quot;plain/text&quot;</span>);

     <span class="keywordtype">int</span> last = std::min(iterations_, iteration + 100);
     <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = iteration; i &lt; last; ++i)
       response.<a class="code" href="classWt_1_1Http_1_1Response.html#ae74ee0009e9ec4aa3d3f35e680a745de" title="Returns the stream for getting the response output.">out</a>() &lt;&lt; <span class="stringliteral">&quot;Data item &quot;</span> &lt;&lt; i &lt;&lt; std::endl;

     <span class="comment">// if we have not yet finished, create a continuation to serve more</span>
     <span class="keywordflow">if</span> (last &lt; iterations_)
       continuation = response.<a class="code" href="classWt_1_1Http_1_1Response.html#a5cb0800718188328fec17d3b84c85aab" title="Create a continuation object for this response.">createContinuation</a>();
       <span class="comment">// remember what to do next</span>
       continuation-&gt;<a class="code" href="classWt_1_1Http_1_1ResponseContinuation.html#a72fa6895f798e1270aa6e6a44222a9eb" title="Set data associated with the continuation.">setData</a>(last);
     }
   }

 <span class="keyword">private</span>:
   <span class="keywordtype">int</span> iterations_;
 };
</pre></div><h3>Global and private resources</h3>
<p>By default, a resource is private to an application: access to it is protected by same secret session Id that protects any other access to the application.</p>
<p>You can also deploy static resources, which are global, using <a class="el" href="classWt_1_1WServer.html#a7b78b5e35d2dc3086faa54f82124cf38" title="Binds a resource to a fixed path.">WServer::addResource()</a>.</p>
<h3>Monitoring upload progress</h3>
<p>A resource may also handle the uploading of files (in fact, <a class="el" href="classWt_1_1WFileUpload.html" title="A widget that allows a file to be uploaded.">WFileUpload</a> uses a <a class="el" href="classWt_1_1WResource.html" title="An object which can be rendered in the HTTP protocol.">WResource</a> to do exactly that) or transmission of other large bodies of data being POST'ed or PUT to the resource URL. For these requests, it may be convenient to enable upload progress monitoring using <a class="el" href="classWt_1_1WResource.html#ae0b96cdd80b982c74adb9a762c77d479" title="Indicate interest in upload progress.">setUploadProgress()</a>, which allows you to be notified of data being received.</p>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="classWt_1_1WAnchor.html" title="A widget that represents an HTML anchor (to link to other documents).">WAnchor</a>, <a class="el" href="classWt_1_1WImage.html" title="A widget that displays an image.">WImage</a> </dd></dl>
<hr/><h2>Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="a776c19c9bbc95330941744cd129bc01a"></a><!-- doxytag: member="Wt::WResource::~WResource" ref="a776c19c9bbc95330941744cd129bc01a" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Wt::WResource::~WResource </td>
          <td>(</td>
          <td class="paramname">&#160;)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Destroys the resource. </p>
<p>When specializing a resource, you MUST call <a class="el" href="classWt_1_1WResource.html#a24f65859427f54012fef2fa9da14870d" title="Prepares the resource for deletion.">beingDeleted()</a> from within the specialized destructor, in order to stop any further requests to the resource. </p>

</div>
</div>
<hr/><h2>Member Function Documentation</h2>
<a class="anchor" id="a24f65859427f54012fef2fa9da14870d"></a><!-- doxytag: member="Wt::WResource::beingDeleted" ref="a24f65859427f54012fef2fa9da14870d" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Wt::WResource::beingDeleted </td>
          <td>(</td>
          <td class="paramname">&#160;)</td>
          <td><code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Prepares the resource for deletion. </p>
<p>When specializing a resource, you MUST call <a class="el" href="classWt_1_1WResource.html#a24f65859427f54012fef2fa9da14870d" title="Prepares the resource for deletion.">beingDeleted()</a> from within the specialized destructor, in order to stop any further requests to the resource. </p>

</div>
</div>
<a class="anchor" id="a1527418354a584790c372e86a40c6027"></a><!-- doxytag: member="Wt::WResource::dataChanged" ref="a1527418354a584790c372e86a40c6027" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classWt_1_1Signal.html">Signal</a>&amp; Wt::WResource::dataChanged </td>
          <td>(</td>
          <td class="paramname">&#160;)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p><a class="el" href="classWt_1_1Signal.html" title="A signal that propagates events to listeners.">Signal</a> emitted when the data presented in this resource has changed. </p>
<p>Widgets that reference the resource (such as anchors and images) will make sure the new data is rendered.</p>
<p>It is better to call <a class="el" href="classWt_1_1WResource.html#a9394f6c2ff6cadf8d1076ec52c5e909a" title="Generates a new URL for this resource and emits the changed signal.">setChanged()</a> than to emit this signal. setChanged generates a new URL for this resource to avoid caching problems and then emits this signal. </p>

</div>
</div>
<a class="anchor" id="a37f002b4919486e057469b92d70c755d"></a><!-- doxytag: member="Wt::WResource::dataReceived" ref="a37f002b4919486e057469b92d70c755d" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classWt_1_1Signal.html">Signal</a>&lt; ::uint64_t, ::uint64_t &gt;&amp; Wt::WResource::dataReceived </td>
          <td>(</td>
          <td class="paramname">&#160;)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p><a class="el" href="classWt_1_1Signal.html" title="A signal that propagates events to listeners.">Signal</a> emitted when data has been received for this resource. </p>
<p>When this signal is emitted, you have the update lock to modify the application. Because there is however no corresponding request from the browser, any update to the user interface is not immediately reflected in the client. To update the client interface, you need to use a <a class="el" href="classWt_1_1WTimer.html" title="A utility class which provides timer signals and single-shot timers.">WTimer</a> or enable <a class="el" href="classWt_1_1WApplication.html#ad9631ca64e68d30d40cb49c90e55223d">server-push</a>.</p>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="classWt_1_1WResource.html#ae0b96cdd80b982c74adb9a762c77d479" title="Indicate interest in upload progress.">setUploadProgress()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a5060efcabde5f793c9d44c5ca557417d"></a><!-- doxytag: member="Wt::WResource::generateUrl" ref="a5060efcabde5f793c9d44c5ca557417d" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const std::string &amp; Wt::WResource::generateUrl </td>
          <td>(</td>
          <td class="paramname">&#160;)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Generates an URL for this resource. </p>
<p>Generates a new url that refers to this resource. The url is unique to assure that it is not cached by the web browser, and can thus be used to refer to a new "version" of the resource, which can be indicated by emitting the <a class="el" href="classWt_1_1WResource.html#a1527418354a584790c372e86a40c6027" title="Signal emitted when the data presented in this resource has changed.">dataChanged()</a> signal.</p>
<p>The old urls are not invalidated by calling this method. </p>

</div>
</div>
<a class="anchor" id="a3a740f8cc29e2e6e4e58defc9c88b8b6"></a><!-- doxytag: member="Wt::WResource::handleRequest" ref="a3a740f8cc29e2e6e4e58defc9c88b8b6" args="(const Http::Request &amp;request, Http::Response &amp;response)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void Wt::WResource::handleRequest </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classWt_1_1Http_1_1Request.html">Http::Request</a> &amp;&#160;</td>
          <td class="paramname"> <em>request</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classWt_1_1Http_1_1Response.html">Http::Response</a> &amp;&#160;</td>
          <td class="paramname"> <em>response</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Handles a request. </p>
<p>Reimplement this method so that a proper response is generated for the given request. From the <code>request</code> object you can access request parameters and whether the request is a continuation request. In the <code>response</code> object, you should set the mime type and stream the output data.</p>
<p>A request may also concern a continuation, indicated in <a class="el" href="classWt_1_1Http_1_1Request.html#a2d4f88961a222be846460a8238823ae0" title="Returns a continuation object.">Http::Request::continuation()</a>, in which case the next part for a previously created continuation should be served.</p>
<p>While handling a request, which may happen at any time together with event handling, the library makes sure that the resource is not being concurrently deleted, but multiple requests may happend simultaneously for a single resource. </p>

<p>Implemented in <a class="el" href="classWt_1_1Ext_1_1DataStore.html#a95828fc3362ef58ff821790180bf9834">Wt::Ext::DataStore</a>, <a class="el" href="classWt_1_1WFileResource.html#a7a801fa115d455a2b8cc29938a29fe85">Wt::WFileResource</a>, <a class="el" href="classWt_1_1WMemoryResource.html#a7800a19988ddf5af4e4ffe0f323316ae">Wt::WMemoryResource</a>, <a class="el" href="classWt_1_1WPdfImage.html#a358347b05123b87af1ced8d038b34f38">Wt::WPdfImage</a>, <a class="el" href="classWt_1_1WRasterImage.html#a636543ffb0fffeb7a9e0dd8a166d3167">Wt::WRasterImage</a>, and <a class="el" href="classWt_1_1WSvgImage.html#ae79007c08cab7b4c9f24f0e0210c02e1">Wt::WSvgImage</a>.</p>

</div>
</div>
<a class="anchor" id="aca0470f44682d5b785045269235a23b0"></a><!-- doxytag: member="Wt::WResource::internalPath" ref="aca0470f44682d5b785045269235a23b0" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string Wt::WResource::internalPath </td>
          <td>(</td>
          <td class="paramname">&#160;)</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns the internal path. </p>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="classWt_1_1WResource.html#a06bb9dbe3ae195c320cfed7b062d448a" title="Sets an internal path for this resource.">setInternalPath()</a>. </dd></dl>

</div>
</div>
<a class="anchor" id="a9394f6c2ff6cadf8d1076ec52c5e909a"></a><!-- doxytag: member="Wt::WResource::setChanged" ref="a9394f6c2ff6cadf8d1076ec52c5e909a" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Wt::WResource::setChanged </td>
          <td>(</td>
          <td class="paramname">&#160;)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Generates a new URL for this resource and emits the changed signal. </p>
<p>This does not work when the resource is deployed at an internal path using <a class="el" href="classWt_1_1WResource.html#a06bb9dbe3ae195c320cfed7b062d448a" title="Sets an internal path for this resource.">setInternalPath()</a>. </p>

</div>
</div>
<a class="anchor" id="a06bb9dbe3ae195c320cfed7b062d448a"></a><!-- doxytag: member="Wt::WResource::setInternalPath" ref="a06bb9dbe3ae195c320cfed7b062d448a" args="(const std::string &amp;path)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Wt::WResource::setInternalPath </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"> <em>path</em>&#160;)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Sets an internal path for this resource. </p>
<p>Using this method you can deploy the resource at a fixed path. Unless you deploy using cookies for session tracking (not recommended), a session identifier will be appended to the path.</p>
<p>You should use internal paths that are different from internal paths handled by your application (<a class="el" href="classWt_1_1WApplication.html#a2c1a10aadc0d7ed877b5715b42ca4911" title="Change the internal path.">WApplication::setInternalPath()</a>), if you do not want a conflict between these two when the browser does not use AJAX (and thus url fragments for its internal paths).</p>
<p>The default value is empty. By default the URL for a resource is unspecified and a URL will be generated by the library.</p>
<p>The internal path for a static resource is the deployment path specified using <a class="el" href="classWt_1_1WServer.html#a7b78b5e35d2dc3086faa54f82124cf38" title="Binds a resource to a fixed path.">WServer::addResource()</a>. </p>

</div>
</div>
<a class="anchor" id="ae0b96cdd80b982c74adb9a762c77d479"></a><!-- doxytag: member="Wt::WResource::setUploadProgress" ref="ae0b96cdd80b982c74adb9a762c77d479" args="(bool enabled)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Wt::WResource::setUploadProgress </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"> <em>enabled</em>&#160;)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Indicate interest in upload progress. </p>
<p>When supported, you can track upload progress using this signal. While data is being received, and before <a class="el" href="classWt_1_1WResource.html#a3a740f8cc29e2e6e4e58defc9c88b8b6" title="Handles a request.">handleRequest()</a> is called, progress information is indicated using <a class="el" href="classWt_1_1WResource.html#a37f002b4919486e057469b92d70c755d" title="Signal emitted when data has been received for this resource.">dataReceived()</a>.</p>
<p>We envision that in the future support will depend on a combination of browser and connector. Currently only the wthttp connector provides support for this across all AJAX browsers. In the future, we are likely to implement this also using JavaScript File API features making it independent of connectors.</p>
<p>The default value is <code>false</code>. </p>

</div>
</div>
<a class="anchor" id="a966ece2e5a3e39d861e156ed0151402e"></a><!-- doxytag: member="Wt::WResource::suggestedFileName" ref="a966ece2e5a3e39d861e156ed0151402e" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const std::string&amp; Wt::WResource::suggestedFileName </td>
          <td>(</td>
          <td class="paramname">&#160;)</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns the suggested file name. </p>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="classWt_1_1WResource.html#a8f2c3c2aa013cebecd73398dadc3d6d0" title="Suggests a filename to the user for the data streamed by this resource.">suggestFileName()</a>; </dd></dl>

</div>
</div>
<a class="anchor" id="a8f2c3c2aa013cebecd73398dadc3d6d0"></a><!-- doxytag: member="Wt::WResource::suggestFileName" ref="a8f2c3c2aa013cebecd73398dadc3d6d0" args="(const std::string &amp;name)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Wt::WResource::suggestFileName </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"> <em>name</em>&#160;)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Suggests a filename to the user for the data streamed by this resource. </p>
<p>For resources, intended to be downloaded by the user, suggest a name used for saving. The filename extension may also help the browser to identify the correct program for opening the resource. </p>

</div>
</div>
<a class="anchor" id="a11169bf885f297f6f2ebbc1789aeded2"></a><!-- doxytag: member="Wt::WResource::url" ref="a11169bf885f297f6f2ebbc1789aeded2" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const std::string &amp; Wt::WResource::url </td>
          <td>(</td>
          <td class="paramname">&#160;)</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns the current URL for this resource. </p>
<p>Returns the url that references this resource. </p>

</div>
</div>
<a class="anchor" id="ad8bbe65a888cc43e0d356f18509b9a0f"></a><!-- doxytag: member="Wt::WResource::write" ref="ad8bbe65a888cc43e0d356f18509b9a0f" args="(std::ostream &amp;out, const Http::ParameterMap &amp;parameters=Http::ParameterMap(), const Http::UploadedFileMap &amp;files=Http::UploadedFileMap())" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Wt::WResource::write </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"> <em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceWt_1_1Http.html#a3420f95c8bfecf3d46e65920c765345a">Http::ParameterMap</a> &amp;&#160;</td>
          <td class="paramname"> <em>parameters</em> = <code><a class="el" href="namespaceWt_1_1Http.html#a3420f95c8bfecf3d46e65920c765345a">Http::ParameterMap</a>()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceWt_1_1Http.html#a90602329029048d738daae9ba63e059a">Http::UploadedFileMap</a> &amp;&#160;</td>
          <td class="paramname"> <em>files</em> = <code><a class="el" href="namespaceWt_1_1Http.html#a90602329029048d738daae9ba63e059a">Http::UploadedFileMap</a>()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Stream the resource to a stream. </p>
<p>This is a convenience method to serialize to a stream (for example a file stream). </p>

</div>
</div>
</div>
<!--- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Namespaces</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Enumerator</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<hr size="1"><address style="text-align: right; margin: 3px"><small>
Generated on Tue Nov 30 2010 for <a href="http://www.webtoolkit.eu/wt">the
C++ Web Toolkit (Wt)</a> by&nbsp;<a
href="http://www.doxygen.org/index.html"><img src="doxygen.png"
alt="doxygen" border="0" style="vertical-align: middle; display:
inline-block; height: 2em"></a> 1.7.2</small></address>
</body>
</html>

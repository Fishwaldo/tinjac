<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>Wt: Wt::WContainerWidget Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javaScript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body onload='searchBox.OnSelectItem(0);'>
<!-- Generated by Doxygen 1.7.2 -->
<script type="text/javascript"><!--
var searchBox = new SearchBox("searchBox", "search",false,'Search');
--></script>
<div class="navigation" id="top">
  <div class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li id="searchli">
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="hierarchy.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
  <div class="navpath">
    <ul>
      <li><a class="el" href="namespaceWt.html">Wt</a>      </li>
      <li><a class="el" href="classWt_1_1WContainerWidget.html">WContainerWidget</a>      </li>
    </ul>
  </div>
</div>
<div class="header">
  <div class="summary">
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a>  </div>
  <div class="headertitle">
<h1>Wt::WContainerWidget Class Reference</h1>  </div>
</div>
<div class="contents">
<!-- doxytag: class="Wt::WContainerWidget" --><!-- doxytag: inherits="Wt::WInteractWidget" -->
<p>A widget that holds and manages child widgets.  
<a href="#_details">More...</a></p>

<p><code>#include &lt;Wt/WContainerWidget&gt;</code></p>
<!-- startSectionHeader --><div class="dynheader">
Inheritance diagram for Wt::WContainerWidget:<!-- endSectionHeader --></div>
<!-- startSectionSummary --><!-- endSectionSummary --><!-- startSectionContent --><div class="dyncontent">
<div class="center"><img src="classWt_1_1WContainerWidget__inherit__graph.png" border="0" usemap="#Wt_1_1WContainerWidget_inherit__map" alt="Inheritance graph"/></div>
<map name="Wt_1_1WContainerWidget_inherit__map" id="Wt_1_1WContainerWidget_inherit__map">
<area shape="rect" href="classWt_1_1Ext_1_1Splitter.html" title="A container widget with resize handles between its children." alt="" coords="928,5,1048,32"/><area shape="rect" href="classWt_1_1WAnchor.html" title="A widget that represents an HTML anchor (to link to other documents)." alt="" coords="939,56,1037,83"/><area shape="rect" href="classWt_1_1WGroupBox.html" title="A widget which group widgets into a frame with a title." alt="" coords="928,107,1048,133"/><area shape="rect" href="classWt_1_1WOverlayLoadingIndicator.html" title="A more obvious loading indicator that grays the window." alt="" coords="884,157,1092,184"/><area shape="rect" href="classWt_1_1WStackedWidget.html" title="A container widget that stacks its widgets on top of each other." alt="" coords="912,208,1064,235"/><area shape="rect" href="classWt_1_1WTableCell.html" title="A container widget that represents a cell in a table." alt="" coords="932,259,1044,285"/><area shape="rect" href="classWt_1_1WInteractWidget.html" title="An abstract widget that can receive user&#45;interface interaction." alt="" coords="476,132,623,159"/><area shape="rect" href="classWt_1_1WWebWidget.html" title="A base class for widgets with an HTML counterpart." alt="" coords="301,132,427,159"/><area shape="rect" href="classWt_1_1WWidget.html" title="The abstract base class for a user&#45;interface component." alt="" coords="153,132,252,159"/><area shape="rect" href="classWt_1_1WObject.html" title="A base class for objects that participate in the signal/slot system." alt="" coords="7,132,103,159"/></map>
<center><span class="legend">[<a href="graph_legend.html">legend</a>]</span></center><!-- endSectionContent --></div>

<p><a href="classWt_1_1WContainerWidget-members.html">List of all members.</a></p>
<table class="memberdecls">
<tr><td colspan="2"><h2><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classWt_1_1WContainerWidget.html#abcc1911965f1669b94bd3f8fbf86a2d6">Overflow</a> { <a class="el" href="classWt_1_1WContainerWidget.html#abcc1911965f1669b94bd3f8fbf86a2d6aa195ca15f69167c8f3087e5bc3e24f68">OverflowVisible</a> = 0x0, 
<a class="el" href="classWt_1_1WContainerWidget.html#abcc1911965f1669b94bd3f8fbf86a2d6ac8fcc7d215f329753187326459cf5856">OverflowAuto</a> = 0x1, 
<a class="el" href="classWt_1_1WContainerWidget.html#abcc1911965f1669b94bd3f8fbf86a2d6ac5ba5a20547ae53b1caef3f05d0c3241">OverflowHidden</a> = 0x2, 
<a class="el" href="classWt_1_1WContainerWidget.html#abcc1911965f1669b94bd3f8fbf86a2d6a3c51faeacd0f1d2c6fa287f5e9932be9">OverflowScroll</a> = 0x3
 }</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight"><p>How to handle overflow of inner content. </p>
 <a href="classWt_1_1WContainerWidget.html#abcc1911965f1669b94bd3f8fbf86a2d6">More...</a><br/></td></tr>
<tr><td colspan="2"><h2><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a520ba6e52a36a7f2efbef1a31a69e898"></a><!-- doxytag: member="Wt::WContainerWidget::WContainerWidget" ref="a520ba6e52a36a7f2efbef1a31a69e898" args="(WContainerWidget *parent=0)" -->
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classWt_1_1WContainerWidget.html#a520ba6e52a36a7f2efbef1a31a69e898">WContainerWidget</a> (<a class="el" href="classWt_1_1WContainerWidget.html">WContainerWidget</a> *parent=0)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a container with optional parent. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="abcdb141e27e673f10c8e0e693307bf94"></a><!-- doxytag: member="Wt::WContainerWidget::~WContainerWidget" ref="abcdb141e27e673f10c8e0e693307bf94" args="()" -->
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classWt_1_1WContainerWidget.html#abcdb141e27e673f10c8e0e693307bf94">~WContainerWidget</a> ()</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Destructor. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classWt_1_1WContainerWidget.html#a1c84e0ffe330d4798f0ce217f75be08c">setLayout</a> (<a class="el" href="classWt_1_1WLayout.html">WLayout</a> *layout)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets a layout manager for the container.  <a href="#a1c84e0ffe330d4798f0ce217f75be08c"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classWt_1_1WContainerWidget.html#aff9884c8efdf90974077e96bcb1701db">setLayout</a> (<a class="el" href="classWt_1_1WLayout.html">WLayout</a> *layout, WFlags&lt; <a class="el" href="namespaceWt.html#ab8f772c69bc8180c31f9e4f4593b143f">AlignmentFlag</a> &gt; alignment)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets a layout manager for the container.  <a href="#aff9884c8efdf90974077e96bcb1701db"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classWt_1_1WLayout.html">WLayout</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classWt_1_1WContainerWidget.html#afaba82a27836f4a82bab48e8b26ccca2">layout</a> ()</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the layout manager that was set for the container.  <a href="#afaba82a27836f4a82bab48e8b26ccca2"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classWt_1_1WContainerWidget.html#a2cfe66d9b62940f889e99538a9f478d2">addWidget</a> (<a class="el" href="classWt_1_1WWidget.html">WWidget</a> *widget)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds a child widget to this container.  <a href="#a2cfe66d9b62940f889e99538a9f478d2"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classWt_1_1WContainerWidget.html#a1439877a32c4b082f312fee81d139665">insertBefore</a> (<a class="el" href="classWt_1_1WWidget.html">WWidget</a> *widget, <a class="el" href="classWt_1_1WWidget.html">WWidget</a> *before)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Inserts a child widget in this container, before another widget.  <a href="#a1439877a32c4b082f312fee81d139665"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classWt_1_1WContainerWidget.html#a15ffcecaf10e6f04ec5667d2b3f0d919">insertWidget</a> (int index, <a class="el" href="classWt_1_1WWidget.html">WWidget</a> *widget)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Inserts a child widget in this container at given index.  <a href="#a15ffcecaf10e6f04ec5667d2b3f0d919"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classWt_1_1WContainerWidget.html#a4292867b1872bd31c7d0c3346d988470">removeWidget</a> (<a class="el" href="classWt_1_1WWidget.html">WWidget</a> *widget)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes a child widget from this container.  <a href="#a4292867b1872bd31c7d0c3346d988470"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classWt_1_1WContainerWidget.html#a608f748cbdda763f1a11556ddad9fbe1">clear</a> ()</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes and deletes all child widgets.  <a href="#a608f748cbdda763f1a11556ddad9fbe1"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a7cf9f4f1c261080bce30b6a6ea19014e"></a><!-- doxytag: member="Wt::WContainerWidget::indexOf" ref="a7cf9f4f1c261080bce30b6a6ea19014e" args="(WWidget *widget) const " -->
virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classWt_1_1WContainerWidget.html#a7cf9f4f1c261080bce30b6a6ea19014e">indexOf</a> (<a class="el" href="classWt_1_1WWidget.html">WWidget</a> *widget) const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the index of a widget. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a53c79a7311ffe3c132b50bdbb830856d"></a><!-- doxytag: member="Wt::WContainerWidget::widget" ref="a53c79a7311ffe3c132b50bdbb830856d" args="(int index) const " -->
virtual <a class="el" href="classWt_1_1WWidget.html">WWidget</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classWt_1_1WContainerWidget.html#a53c79a7311ffe3c132b50bdbb830856d">widget</a> (int index) const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the widget at <em>index</em> <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a85abd4d928575717052ff7fa04c3c2c9"></a><!-- doxytag: member="Wt::WContainerWidget::count" ref="a85abd4d928575717052ff7fa04c3c2c9" args="() const " -->
virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classWt_1_1WContainerWidget.html#a85abd4d928575717052ff7fa04c3c2c9">count</a> () const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of widgets in this container. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classWt_1_1WContainerWidget.html#aba13c9e62c74bcba53519ee9cf41f40a">setContentAlignment</a> (WFlags&lt; <a class="el" href="namespaceWt.html#ab8f772c69bc8180c31f9e4f4593b143f">AlignmentFlag</a> &gt; contentAlignment)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Specifies how child widgets must be aligned within the container.  <a href="#aba13c9e62c74bcba53519ee9cf41f40a"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classWt_1_1WContainerWidget.html#afa5f6800e2170ae2f4586a25c72f8c34">setPadding</a> (const <a class="el" href="classWt_1_1WLength.html">WLength</a> &amp;padding, WFlags&lt; <a class="el" href="namespaceWt.html#a5a6f4636bcc6ab3c075165d249b3a5a3">Side</a> &gt; sides=<a class="el" href="namespaceWt.html#a3358b8309fdb63a402efcb1a577855e8">All</a>)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets padding inside the widget.  <a href="#afa5f6800e2170ae2f4586a25c72f8c34"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classWt_1_1WLength.html">WLength</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classWt_1_1WContainerWidget.html#a326a0c9d7e4307dfd9c6979a2c441a96">padding</a> (<a class="el" href="namespaceWt.html#a5a6f4636bcc6ab3c075165d249b3a5a3">Side</a> side) const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the padding set for the widget.  <a href="#a326a0c9d7e4307dfd9c6979a2c441a96"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">WFlags&lt; <a class="el" href="namespaceWt.html#ab8f772c69bc8180c31f9e4f4593b143f">AlignmentFlag</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classWt_1_1WContainerWidget.html#a042dbe790f34279f1978bc87610933df">contentAlignment</a> () const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the alignment of children.  <a href="#a042dbe790f34279f1978bc87610933df"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classWt_1_1WContainerWidget.html#ae269f870992c5843d3097a63795b10d6">setOverflow</a> (<a class="el" href="classWt_1_1WContainerWidget.html#abcc1911965f1669b94bd3f8fbf86a2d6">Overflow</a> overflow, WFlags&lt; <a class="el" href="namespaceWt.html#a2a8d45559e16a0185bf61bfad0a67912">Orientation</a> &gt; orientation=(Horizontal|Vertical))</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets how overflow of contained children must be handled.  <a href="#ae269f870992c5843d3097a63795b10d6"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classWt_1_1WContainerWidget.html#a4b1857ba8e8a677887cd20aa657fb77f">setList</a> (bool list, bool ordered=false)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Renders the container as an HTML list.  <a href="#a4b1857ba8e8a677887cd20aa657fb77f"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classWt_1_1WContainerWidget.html#a2ba1ccbc634a57f21608c410d28bbff5">isList</a> () const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns if this container is rendered as a List.  <a href="#a2ba1ccbc634a57f21608c410d28bbff5"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classWt_1_1WContainerWidget.html#ae0db17987ae260b71d860b8f670c0c8a">isUnorderedList</a> () const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns if this container is rendered as an Unordered List.  <a href="#ae0db17987ae260b71d860b8f670c0c8a"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classWt_1_1WContainerWidget.html#af7c9ba23a66d27cb7442557284464f3f">isOrderedList</a> () const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns if this container is rendered as an Ordered List.  <a href="#af7c9ba23a66d27cb7442557284464f3f"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classWt_1_1EventSignal.html">EventSignal</a>&lt; <a class="el" href="classWt_1_1WScrollEvent.html">WScrollEvent</a> &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classWt_1_1WContainerWidget.html#a64b97ae076fc6d678305fcdf77738a31">scrolled</a> ()</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Event signal emitted when scrolling in the widget.  <a href="#a64b97ae076fc6d678305fcdf77738a31"></a><br/></td></tr>
</table>
<hr/><a name="_details"></a><h2>Detailed Description</h2>
<p>A widget that holds and manages child widgets. </p>
<p>A WContainerWidget acts as a container for child widgets. Child widgets may be added directly to the container or using a layout manager.</p>
<p>Use <a class="el" href="classWt_1_1WContainerWidget.html#a2cfe66d9b62940f889e99538a9f478d2" title="Adds a child widget to this container.">addWidget()</a> or pass the container as constructor argument to a widget to directly add children to the container, without using a layout manager. In that case, CSS-based layout is used, and the resulting display is determined by properties of the children and the container. By default, a WContainerWidget is displayed as a <a class="el" href="classWt_1_1WWidget.html#ac78e3af143883334c82031790c87416e">block </a> and manages its children within a rectangle. Inline child widgets are layed out in lines, wrapping around as needed, while block child widgets are stacked vertically. The container may add padding at the container edges using <a class="el" href="classWt_1_1WContainerWidget.html#afa5f6800e2170ae2f4586a25c72f8c34" title="Sets padding inside the widget.">setPadding()</a>, and provide alignment of contents using <a class="el" href="classWt_1_1WContainerWidget.html#aba13c9e62c74bcba53519ee9cf41f40a" title="Specifies how child widgets must be aligned within the container.">setContentAlignment()</a>. A container is rendered by default using a HTML <code>div</code> tag, but this may be changed to an HTML <code>ul</code> or <code>ol</code> tag to make use of other CSS layout techniques, using <a class="el" href="classWt_1_1WContainerWidget.html#a4b1857ba8e8a677887cd20aa657fb77f" title="Renders the container as an HTML list.">setList()</a>. In addition, specializations of this class as implemented by <a class="el" href="classWt_1_1WAnchor.html" title="A widget that represents an HTML anchor (to link to other documents).">WAnchor</a>, <a class="el" href="classWt_1_1WGroupBox.html" title="A widget which group widgets into a frame with a title.">WGroupBox</a>, <a class="el" href="classWt_1_1WStackedWidget.html" title="A container widget that stacks its widgets on top of each other.">WStackedWidget</a> and <a class="el" href="classWt_1_1WTableCell.html" title="A container widget that represents a cell in a table.">WTableCell</a> provide other alternative rendering of the container.</p>
<p>When setting the WContainerWidget <a class="el" href="classWt_1_1WWidget.html#ac78e3af143883334c82031790c87416e">inline </a> the container only acts as a conceptual container, offering a common style to its children. Inline children are still layed out inline within the flow of the parent container of this container, as if they were inserted directly into that parent container. Block children are then not allowed (according to the HTML specification).</p>
<p>To use a layout manager instead of CSS-based layout, use <a class="el" href="classWt_1_1WContainerWidget.html#a1c84e0ffe330d4798f0ce217f75be08c" title="Sets a layout manager for the container.">setLayout()</a> or pass the container as constructor argument to a layout manager. In that case you should not define any padding for the container, and widgets and nested layout managers must be added to the layout manager, instead of to the container directly.</p>
<p>Usage example: </p>
<div class="fragment"><pre class="fragment"> <span class="comment">// Example 1:</span>
 <span class="comment">// Instantiate a container widget and add some children whose layout </span>
 <span class="comment">// is governed based on HTML/CSS rules.</span>
 <a class="code" href="classWt_1_1WContainerWidget.html" title="A widget that holds and manages child widgets.">Wt::WContainerWidget</a> *container1 = <span class="keyword">new</span> <a class="code" href="classWt_1_1WContainerWidget.html#a520ba6e52a36a7f2efbef1a31a69e898" title="Creates a container with optional parent.">Wt::WContainerWidget</a>();
 container1-&gt;<a class="code" href="classWt_1_1WContainerWidget.html#a2cfe66d9b62940f889e99538a9f478d2" title="Adds a child widget to this container.">addWidget</a>(<span class="keyword">new</span> <a class="code" href="classWt_1_1WText.html" title="A widget that renders (XHTML) text.">Wt::WText</a>(<span class="stringliteral">&quot;Some text&quot;</span>));
 container1-&gt;<a class="code" href="classWt_1_1WContainerWidget.html#a2cfe66d9b62940f889e99538a9f478d2" title="Adds a child widget to this container.">addWidget</a>(<span class="keyword">new</span> <a class="code" href="classWt_1_1WImage.html" title="A widget that displays an image.">Wt::WImage</a>(<span class="stringliteral">&quot;images/img.png&quot;</span>));
 <a class="code" href="classWt_1_1WContainerWidget.html" title="A widget that holds and manages child widgets.">Wt::WContainerWidget</a> *child3 = <span class="keyword">new</span> <a class="code" href="classWt_1_1WContainerWidget.html#a520ba6e52a36a7f2efbef1a31a69e898" title="Creates a container with optional parent.">Wt::WContainerWidget</a>(container1);

 <span class="comment">// Example 2:</span>
 <span class="comment">// Instantiate a container widget which uses a layout manager</span>
 <a class="code" href="classWt_1_1WContainerWidget.html" title="A widget that holds and manages child widgets.">Wt::WContainerWidget</a> *container2 = <span class="keyword">new</span> <a class="code" href="classWt_1_1WContainerWidget.html#a520ba6e52a36a7f2efbef1a31a69e898" title="Creates a container with optional parent.">Wt::WContainerWidget</a>();
 container2-&gt;<a class="code" href="classWt_1_1WWebWidget.html#ae1b84e31581405358b6d57ec14505234" title="Resizes the widget.">resize</a>(<a class="code" href="classWt_1_1WLength.html#a0cf39ca4225776879d56ade60320c31a" title="An &amp;#39;auto&amp;#39; length.">WLength::Auto</a>, 600); <span class="comment">// give the container a fixed height.</span>

 <a class="code" href="classWt_1_1WVBoxLayout.html" title="A layout manager which arranges widgets vertically.">Wt::WVBoxLayout</a> *layout = <span class="keyword">new</span> <a class="code" href="classWt_1_1WVBoxLayout.html" title="A layout manager which arranges widgets vertically.">Wt::WVBoxLayout</a>();
 layout-&gt;<a class="code" href="classWt_1_1WBoxLayout.html#a7c1ec58e25d0b7add93f5f4342844db6" title="Adds a widget to the layout.">addWidget</a>(<span class="keyword">new</span> <a class="code" href="classWt_1_1WText.html" title="A widget that renders (XHTML) text.">Wt::WText</a>(<span class="stringliteral">&quot;Some text&quot;</span>));
 layout-&gt;<a class="code" href="classWt_1_1WBoxLayout.html#a7c1ec58e25d0b7add93f5f4342844db6" title="Adds a widget to the layout.">addWidget</a>(<span class="keyword">new</span> <a class="code" href="classWt_1_1WImage.html" title="A widget that displays an image.">Wt::WImage</a>(<span class="stringliteral">&quot;images/img.png&quot;</span>));

 container2-&gt;<a class="code" href="classWt_1_1WContainerWidget.html#a1c84e0ffe330d4798f0ce217f75be08c" title="Sets a layout manager for the container.">setLayout</a>(layout);      <span class="comment">// set the layout to the container.</span>
</pre></div><p>When using a layout manager, you need to carefully consider the alignment of the layout manager with respect to the container: when the container's height is unconstrained (not specified explicitly using <a class="el" href="classWt_1_1WWebWidget.html#ae1b84e31581405358b6d57ec14505234" title="Resizes the widget.">resize()</a> or a style class, and the container is not included in a layout manager), you should pass AlignTop to <a class="el" href="classWt_1_1WContainerWidget.html#a1c84e0ffe330d4798f0ce217f75be08c" title="Sets a layout manager for the container.">setLayout()</a>.</p>
<h3>CSS</h3>
<p>Depending on its configuration and usage, the widget corresponds to the following HTML tags:</p>
<ul>
<li>By default, the widget corresponds to a <code>&lt;div&gt;</code> tag.</li>
<li>When configured with setInline(true), the widget corresponds to a <code>&lt;span&gt;</code>.</li>
<li>When configured with setList(true), the widget corresponds to a <code>&lt;ul&gt;</code>.</li>
<li>When configured with setList(true, true), the widget corresponds to a <code>&lt;ol&gt;</code>.</li>
<li>When inserted into a container widget that <a class="el" href="classWt_1_1WContainerWidget.html#a2ba1ccbc634a57f21608c410d28bbff5" title="Returns if this container is rendered as a List.">isList()</a>, the widget corresponds to a <code>&lt;li&gt;</code>.</li>
</ul>
<p>This widget does not provide styling, and can be styled using inline or external CSS as appropriate. </p>
<hr/><h2>Member Enumeration Documentation</h2>
<a class="anchor" id="abcc1911965f1669b94bd3f8fbf86a2d6"></a><!-- doxytag: member="Wt::WContainerWidget::Overflow" ref="abcc1911965f1669b94bd3f8fbf86a2d6" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="classWt_1_1WContainerWidget.html#abcc1911965f1669b94bd3f8fbf86a2d6">Wt::WContainerWidget::Overflow</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>How to handle overflow of inner content. </p>
<dl><dt><b>Enumerator: </b></dt><dd><table border="0" cellspacing="2" cellpadding="0">
<tr><td valign="top"><em><a class="anchor" id="abcc1911965f1669b94bd3f8fbf86a2d6aa195ca15f69167c8f3087e5bc3e24f68"></a><!-- doxytag: member="OverflowVisible" ref="abcc1911965f1669b94bd3f8fbf86a2d6aa195ca15f69167c8f3087e5bc3e24f68" args="" -->OverflowVisible</em>&nbsp;</td><td>
<p>Show content that overflows. </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="abcc1911965f1669b94bd3f8fbf86a2d6ac8fcc7d215f329753187326459cf5856"></a><!-- doxytag: member="OverflowAuto" ref="abcc1911965f1669b94bd3f8fbf86a2d6ac8fcc7d215f329753187326459cf5856" args="" -->OverflowAuto</em>&nbsp;</td><td>
<p>Show scrollbars when needed. </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="abcc1911965f1669b94bd3f8fbf86a2d6ac5ba5a20547ae53b1caef3f05d0c3241"></a><!-- doxytag: member="OverflowHidden" ref="abcc1911965f1669b94bd3f8fbf86a2d6ac5ba5a20547ae53b1caef3f05d0c3241" args="" -->OverflowHidden</em>&nbsp;</td><td>
<p>Hide content that overflows. </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="abcc1911965f1669b94bd3f8fbf86a2d6a3c51faeacd0f1d2c6fa287f5e9932be9"></a><!-- doxytag: member="OverflowScroll" ref="abcc1911965f1669b94bd3f8fbf86a2d6a3c51faeacd0f1d2c6fa287f5e9932be9" args="" -->OverflowScroll</em>&nbsp;</td><td>
<p>Always show scroll bars. </p>
</td></tr>
</table>
</dd>
</dl>

</div>
</div>
<hr/><h2>Member Function Documentation</h2>
<a class="anchor" id="a2cfe66d9b62940f889e99538a9f478d2"></a><!-- doxytag: member="Wt::WContainerWidget::addWidget" ref="a2cfe66d9b62940f889e99538a9f478d2" args="(WWidget *widget)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Wt::WContainerWidget::addWidget </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classWt_1_1WWidget.html">WWidget</a> *&#160;</td>
          <td class="paramname"> <em>widget</em>&#160;)</td>
          <td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Adds a child widget to this container. </p>
<p>This is equivalent to passing this container as the parent when constructing the child. The widget is appended to the list of children, and thus also layed-out at the end. </p>

<p>Reimplemented in <a class="el" href="classWt_1_1Ext_1_1Splitter.html#a3f776ab5a6c84ebfa1d4896b475fec7a">Wt::Ext::Splitter</a>, and <a class="el" href="classWt_1_1WStackedWidget.html#affaa67bed3b16d9cca3c83a1d9386918">Wt::WStackedWidget</a>.</p>

</div>
</div>
<a class="anchor" id="a608f748cbdda763f1a11556ddad9fbe1"></a><!-- doxytag: member="Wt::WContainerWidget::clear" ref="a608f748cbdda763f1a11556ddad9fbe1" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Wt::WContainerWidget::clear </td>
          <td>(</td>
          <td class="paramname">&#160;)</td>
          <td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Removes and deletes all child widgets. </p>
<p>This deletes all children that have been added to this container.</p>
<p>If a layout was set, also the layout manager is deleted. </p>

</div>
</div>
<a class="anchor" id="a042dbe790f34279f1978bc87610933df"></a><!-- doxytag: member="Wt::WContainerWidget::contentAlignment" ref="a042dbe790f34279f1978bc87610933df" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">WFlags&lt;<a class="el" href="namespaceWt.html#ab8f772c69bc8180c31f9e4f4593b143f">AlignmentFlag</a>&gt; Wt::WContainerWidget::contentAlignment </td>
          <td>(</td>
          <td class="paramname">&#160;)</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns the alignment of children. </p>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="classWt_1_1WContainerWidget.html#aba13c9e62c74bcba53519ee9cf41f40a" title="Specifies how child widgets must be aligned within the container.">setContentAlignment(WFlags&lt;AlignmentFlag&gt;)</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a1439877a32c4b082f312fee81d139665"></a><!-- doxytag: member="Wt::WContainerWidget::insertBefore" ref="a1439877a32c4b082f312fee81d139665" args="(WWidget *widget, WWidget *before)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Wt::WContainerWidget::insertBefore </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classWt_1_1WWidget.html">WWidget</a> *&#160;</td>
          <td class="paramname"> <em>widget</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classWt_1_1WWidget.html">WWidget</a> *&#160;</td>
          <td class="paramname"> <em>before</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Inserts a child widget in this container, before another widget. </p>
<p>The <em>widget</em> is inserted at the place of the <code>before</code> widget, and subsequent widgets are shifted.</p>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="classWt_1_1WContainerWidget.html#a15ffcecaf10e6f04ec5667d2b3f0d919" title="Inserts a child widget in this container at given index.">insertWidget(int index, WWidget *widget)</a>; </dd></dl>

<p>Reimplemented in <a class="el" href="classWt_1_1Ext_1_1Splitter.html#ad156963c4ad3d725e0d8b4bd2969b2f7">Wt::Ext::Splitter</a>.</p>

</div>
</div>
<a class="anchor" id="a15ffcecaf10e6f04ec5667d2b3f0d919"></a><!-- doxytag: member="Wt::WContainerWidget::insertWidget" ref="a15ffcecaf10e6f04ec5667d2b3f0d919" args="(int index, WWidget *widget)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Wt::WContainerWidget::insertWidget </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"> <em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classWt_1_1WWidget.html">WWidget</a> *&#160;</td>
          <td class="paramname"> <em>widget</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Inserts a child widget in this container at given index. </p>
<p>The <em>widget</em> is inserted at the given <code>index</code>, and subsequent widgets are shifted.</p>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="classWt_1_1WContainerWidget.html#a1439877a32c4b082f312fee81d139665" title="Inserts a child widget in this container, before another widget.">insertBefore(WWidget *widget, WWidget *before)</a>; </dd></dl>

<p>Reimplemented in <a class="el" href="classWt_1_1Ext_1_1Splitter.html#a4495c1d701edd2181dbc1bf071442363">Wt::Ext::Splitter</a>, and <a class="el" href="classWt_1_1WStackedWidget.html#a7a199e9cf57bee54333880534070767c">Wt::WStackedWidget</a>.</p>

</div>
</div>
<a class="anchor" id="a2ba1ccbc634a57f21608c410d28bbff5"></a><!-- doxytag: member="Wt::WContainerWidget::isList" ref="a2ba1ccbc634a57f21608c410d28bbff5" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Wt::WContainerWidget::isList </td>
          <td>(</td>
          <td class="paramname">&#160;)</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns if this container is rendered as a List. </p>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="classWt_1_1WContainerWidget.html#a4b1857ba8e8a677887cd20aa657fb77f" title="Renders the container as an HTML list.">setList()</a>, <a class="el" href="classWt_1_1WContainerWidget.html#af7c9ba23a66d27cb7442557284464f3f" title="Returns if this container is rendered as an Ordered List.">isOrderedList()</a>, <a class="el" href="classWt_1_1WContainerWidget.html#ae0db17987ae260b71d860b8f670c0c8a" title="Returns if this container is rendered as an Unordered List.">isUnorderedList()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="af7c9ba23a66d27cb7442557284464f3f"></a><!-- doxytag: member="Wt::WContainerWidget::isOrderedList" ref="af7c9ba23a66d27cb7442557284464f3f" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Wt::WContainerWidget::isOrderedList </td>
          <td>(</td>
          <td class="paramname">&#160;)</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns if this container is rendered as an Ordered List. </p>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="classWt_1_1WContainerWidget.html#a4b1857ba8e8a677887cd20aa657fb77f" title="Renders the container as an HTML list.">setList()</a>, <a class="el" href="classWt_1_1WContainerWidget.html#a2ba1ccbc634a57f21608c410d28bbff5" title="Returns if this container is rendered as a List.">isList()</a>, <a class="el" href="classWt_1_1WContainerWidget.html#ae0db17987ae260b71d860b8f670c0c8a" title="Returns if this container is rendered as an Unordered List.">isUnorderedList()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="ae0db17987ae260b71d860b8f670c0c8a"></a><!-- doxytag: member="Wt::WContainerWidget::isUnorderedList" ref="ae0db17987ae260b71d860b8f670c0c8a" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Wt::WContainerWidget::isUnorderedList </td>
          <td>(</td>
          <td class="paramname">&#160;)</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns if this container is rendered as an Unordered List. </p>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="classWt_1_1WContainerWidget.html#a4b1857ba8e8a677887cd20aa657fb77f" title="Renders the container as an HTML list.">setList()</a>, <a class="el" href="classWt_1_1WContainerWidget.html#a2ba1ccbc634a57f21608c410d28bbff5" title="Returns if this container is rendered as a List.">isList()</a>, <a class="el" href="classWt_1_1WContainerWidget.html#af7c9ba23a66d27cb7442557284464f3f" title="Returns if this container is rendered as an Ordered List.">isOrderedList()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="afaba82a27836f4a82bab48e8b26ccca2"></a><!-- doxytag: member="Wt::WContainerWidget::layout" ref="afaba82a27836f4a82bab48e8b26ccca2" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classWt_1_1WLayout.html">WLayout</a>* Wt::WContainerWidget::layout </td>
          <td>(</td>
          <td class="paramname">&#160;)</td>
          <td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns the layout manager that was set for the container. </p>
<p>If no layout manager was previously set using setLayout(<a class="el" href="classWt_1_1WLayout.html" title="An abstract base class for layout managers.">WLayout</a> *), 0 is returned.</p>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="classWt_1_1WContainerWidget.html#a1c84e0ffe330d4798f0ce217f75be08c" title="Sets a layout manager for the container.">setLayout(WLayout *)</a> </dd></dl>

<p>Reimplemented from <a class="el" href="classWt_1_1WWidget.html">Wt::WWidget</a>.</p>

</div>
</div>
<a class="anchor" id="a326a0c9d7e4307dfd9c6979a2c441a96"></a><!-- doxytag: member="Wt::WContainerWidget::padding" ref="a326a0c9d7e4307dfd9c6979a2c441a96" args="(Side side) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classWt_1_1WLength.html">WLength</a> Wt::WContainerWidget::padding </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceWt.html#a5a6f4636bcc6ab3c075165d249b3a5a3">Side</a>&#160;</td>
          <td class="paramname"> <em>side</em>&#160;)</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns the padding set for the widget. </p>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="classWt_1_1WContainerWidget.html#afa5f6800e2170ae2f4586a25c72f8c34" title="Sets padding inside the widget.">setPadding(const WLength&amp;, WFlags&lt;Side&gt;)</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a4292867b1872bd31c7d0c3346d988470"></a><!-- doxytag: member="Wt::WContainerWidget::removeWidget" ref="a4292867b1872bd31c7d0c3346d988470" args="(WWidget *widget)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Wt::WContainerWidget::removeWidget </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classWt_1_1WWidget.html">WWidget</a> *&#160;</td>
          <td class="paramname"> <em>widget</em>&#160;)</td>
          <td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Removes a child widget from this container. </p>
<p>This removes the widget from this container, but does not delete the widget ! </p>

</div>
</div>
<a class="anchor" id="a64b97ae076fc6d678305fcdf77738a31"></a><!-- doxytag: member="Wt::WContainerWidget::scrolled" ref="a64b97ae076fc6d678305fcdf77738a31" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classWt_1_1EventSignal.html">EventSignal</a>&lt; <a class="el" href="classWt_1_1WScrollEvent.html">WScrollEvent</a> &gt; &amp; Wt::WContainerWidget::scrolled </td>
          <td>(</td>
          <td class="paramname">&#160;)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Event signal emitted when scrolling in the widget. </p>
<p>This event is emitted when the user scrolls in the widget (for setting the scroll bar policy, see <a class="el" href="classWt_1_1WContainerWidget.html#ae269f870992c5843d3097a63795b10d6" title="Sets how overflow of contained children must be handled.">setOverflow()</a>). The event conveys details such as the new scroll bar position, the total contents height and the current widget height.</p>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="classWt_1_1WContainerWidget.html#ae269f870992c5843d3097a63795b10d6" title="Sets how overflow of contained children must be handled.">setOverflow()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="aba13c9e62c74bcba53519ee9cf41f40a"></a><!-- doxytag: member="Wt::WContainerWidget::setContentAlignment" ref="aba13c9e62c74bcba53519ee9cf41f40a" args="(WFlags&lt; AlignmentFlag &gt; contentAlignment)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Wt::WContainerWidget::setContentAlignment </td>
          <td>(</td>
          <td class="paramtype">WFlags&lt; <a class="el" href="namespaceWt.html#ab8f772c69bc8180c31f9e4f4593b143f">AlignmentFlag</a> &gt;&#160;</td>
          <td class="paramname"> <em>contentAlignment</em>&#160;)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Specifies how child widgets must be aligned within the container. </p>
<p>For a <a class="el" href="classWt_1_1WContainerWidget.html" title="A widget that holds and manages child widgets.">WContainerWidget</a>, only specifes the horizontal alignment of child widgets. Note that there is no way to specify vertical alignment: children are always pushed to the top of the container.</p>
<p>For a <a class="el" href="classWt_1_1WTableCell.html" title="A container widget that represents a cell in a table.">WTableCell</a>, this may also specify the vertical alignment. The default alignment is (<a class="el" href="namespaceWt.html#ab8f772c69bc8180c31f9e4f4593b143fa58fe5182bd266132c59718c6d30945a9" title="Align top of widget with top of tallest sibling widget.">Wt::AlignTop</a> | <a class="el" href="namespaceWt.html#ab8f772c69bc8180c31f9e4f4593b143fad033ef69b45d0b75633be34168c9b606" title="Align to the left.">Wt::AlignLeft</a>). </p>

</div>
</div>
<a class="anchor" id="a1c84e0ffe330d4798f0ce217f75be08c"></a><!-- doxytag: member="Wt::WContainerWidget::setLayout" ref="a1c84e0ffe330d4798f0ce217f75be08c" args="(WLayout *layout)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Wt::WContainerWidget::setLayout </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classWt_1_1WLayout.html">WLayout</a> *&#160;</td>
          <td class="paramname"> <em>layout</em>&#160;)</td>
          <td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Sets a layout manager for the container. </p>
<p>Note that you can nest layout managers inside each other, to create a complex layout hierarchy.</p>
<p>If a previous layout manager was already set, it is first deleted. In that case, you will need to make sure that you either readd all widgets that were part of the previous layout to the new layout, or delete them, to avoid memory leaks.</p>
<p>The layout manager arranges children in the entire width and height of the container. This is equivalent to <a class="el" href="classWt_1_1WContainerWidget.html#aff9884c8efdf90974077e96bcb1701db">setLayout(layout, AlignJustify)</a></p>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="classWt_1_1WContainerWidget.html#afaba82a27836f4a82bab48e8b26ccca2" title="Returns the layout manager that was set for the container.">layout()</a>, <a class="el" href="classWt_1_1WContainerWidget.html#aff9884c8efdf90974077e96bcb1701db" title="Sets a layout manager for the container.">setLayout(WLayout *, WFlags&lt;AlignmentFlag&gt;)</a> </dd></dl>

<p>Reimplemented from <a class="el" href="classWt_1_1WWidget.html">Wt::WWidget</a>.</p>

</div>
</div>
<a class="anchor" id="aff9884c8efdf90974077e96bcb1701db"></a><!-- doxytag: member="Wt::WContainerWidget::setLayout" ref="aff9884c8efdf90974077e96bcb1701db" args="(WLayout *layout, WFlags&lt; AlignmentFlag &gt; alignment)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Wt::WContainerWidget::setLayout </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classWt_1_1WLayout.html">WLayout</a> *&#160;</td>
          <td class="paramname"> <em>layout</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">WFlags&lt; <a class="el" href="namespaceWt.html#ab8f772c69bc8180c31f9e4f4593b143f">AlignmentFlag</a> &gt;&#160;</td>
          <td class="paramname"> <em>alignment</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Sets a layout manager for the container. </p>
<p>The <code>alignment</code> argument determines how the layout is aligned inside the container. By default, the layout manager arranges children over the entire width and height of the container, corresponding to a value of AlignJustify. This requires that the container has a specified height (either because it is managed by another layout manager, is the root container widget, or has a height set).</p>
<p>In general, <code>alignment</code> is the logical OR of a horizontal and a vertical flag:</p>
<ul>
<li>The horizontal alignment option may be one of <a class="el" href="namespaceWt.html#ab8f772c69bc8180c31f9e4f4593b143fad033ef69b45d0b75633be34168c9b606" title="Align to the left.">Wt::AlignLeft</a>, <a class="el" href="namespaceWt.html#ab8f772c69bc8180c31f9e4f4593b143fa121104cdbb5db77c7d038813a93998e5" title="Align horizontally in the center.">Wt::AlignCenter</a>, <a class="el" href="namespaceWt.html#ab8f772c69bc8180c31f9e4f4593b143fab250310385383f0b2f68d4e0ad5567e1" title="Align to the right.">Wt::AlignRight</a>, or <a class="el" href="namespaceWt.html#ab8f772c69bc8180c31f9e4f4593b143fa18cdf9d975a5a41afa182aabfde0de88" title="Justify left and right.">Wt::AlignJustify</a>.</li>
<li>The vertical alignment option may be '0' (corresponding to vertical justification to the full height), or <a class="el" href="namespaceWt.html#ab8f772c69bc8180c31f9e4f4593b143fa58fe5182bd266132c59718c6d30945a9" title="Align top of widget with top of tallest sibling widget.">Wt::AlignTop</a>.</li>
</ul>
<p>When using a horizontal alingment different from <a class="el" href="namespaceWt.html#ab8f772c69bc8180c31f9e4f4593b143fa18cdf9d975a5a41afa182aabfde0de88" title="Justify left and right.">Wt::AlignJustify</a>, and a vertical alignment different from '0', the widget is sized in that direction to fit the contents, instead of the contents being adjusted to the widget size. This is useful when the container does not have a specific size in that direction and when the layout manager does not contain any widgets that wish to consume all remaining space in that direction.</p>
<p>Only a single layout manager may be set. If you want to replace the current layout manager, you have to erase all contents first using <a class="el" href="classWt_1_1WContainerWidget.html#a608f748cbdda763f1a11556ddad9fbe1" title="Removes and deletes all child widgets.">clear()</a>, which also deletes the layout manager.</p>
<p>Note that you can nest layout managers inside each other, to create a complex layout hierarchy.</p>
<p>The widget will take ownership of <code>layout</code>.</p>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="classWt_1_1WContainerWidget.html#afaba82a27836f4a82bab48e8b26ccca2" title="Returns the layout manager that was set for the container.">layout()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a4b1857ba8e8a677887cd20aa657fb77f"></a><!-- doxytag: member="Wt::WContainerWidget::setList" ref="a4b1857ba8e8a677887cd20aa657fb77f" args="(bool list, bool ordered=false)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Wt::WContainerWidget::setList </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"> <em>list</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"> <em>ordered</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Renders the container as an HTML list. </p>
<p>Setting <code>renderList</code> to <code>true</code> will cause the container to be using an HTML <code>&lt;ul&gt;</code> or <code>&lt;ol&gt;</code> type, depending on the value of <code>orderedList</code>. This must be set before the initial render of the container. When set, any contained <a class="el" href="classWt_1_1WContainerWidget.html" title="A widget that holds and manages child widgets.">WContainerWidget</a> will be rendered as an HTML <code>&lt;li&gt;</code>. Adding non-WContainerWidget children results in unspecified behaviour.</p>
<p>Note that CSS default layout rules for <code>&lt;ul&gt;</code> and <code>&lt;ol&gt;</code> add margin and padding to the container, which may look odd if you do not use bullets.</p>
<p>By default, a container is rendered using a <code>&lt;div&gt;</code> element.</p>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="classWt_1_1WContainerWidget.html#a2ba1ccbc634a57f21608c410d28bbff5" title="Returns if this container is rendered as a List.">isList()</a>, <a class="el" href="classWt_1_1WContainerWidget.html#af7c9ba23a66d27cb7442557284464f3f" title="Returns if this container is rendered as an Ordered List.">isOrderedList()</a>, <a class="el" href="classWt_1_1WContainerWidget.html#ae0db17987ae260b71d860b8f670c0c8a" title="Returns if this container is rendered as an Unordered List.">isUnorderedList()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="ae269f870992c5843d3097a63795b10d6"></a><!-- doxytag: member="Wt::WContainerWidget::setOverflow" ref="ae269f870992c5843d3097a63795b10d6" args="(Overflow overflow, WFlags&lt; Orientation &gt; orientation=(Horizontal|Vertical))" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Wt::WContainerWidget::setOverflow </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classWt_1_1WContainerWidget.html#abcc1911965f1669b94bd3f8fbf86a2d6">Overflow</a>&#160;</td>
          <td class="paramname"> <em>overflow</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">WFlags&lt; <a class="el" href="namespaceWt.html#a2a8d45559e16a0185bf61bfad0a67912">Orientation</a> &gt;&#160;</td>
          <td class="paramname"> <em>orientation</em> = <code>(Horizontal&#160;|&#160;Vertical)</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Sets how overflow of contained children must be handled. </p>
<p>This is an alternative (CSS-ish) way to provide scroll bars on a container widget, compared to wrapping inside a <a class="el" href="classWt_1_1WScrollArea.html" title="A widget that adds scrolling capabilities to its content.">WScrollArea</a>.</p>
<p>Note that currently, you cannot separately specify vertical and horizontal scroll behaviour, since this is not supported on Opera. Therefore, settings will apply automatically to both orientations.</p>
<p>Unlike <a class="el" href="classWt_1_1WScrollArea.html" title="A widget that adds scrolling capabilities to its content.">WScrollArea</a>, horizontal scrolling does not work reliably when the container widget is inserted in a layout manager: the layout manager will overflow rather than use scrollbars for this container widget. A solution there is to use <a class="el" href="classWt_1_1WScrollArea.html" title="A widget that adds scrolling capabilities to its content.">WScrollArea</a> instead.</p>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="classWt_1_1WScrollArea.html" title="A widget that adds scrolling capabilities to its content.">WScrollArea</a> </dd></dl>

</div>
</div>
<a class="anchor" id="afa5f6800e2170ae2f4586a25c72f8c34"></a><!-- doxytag: member="Wt::WContainerWidget::setPadding" ref="afa5f6800e2170ae2f4586a25c72f8c34" args="(const WLength &amp;padding, WFlags&lt; Side &gt; sides=All)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Wt::WContainerWidget::setPadding </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classWt_1_1WLength.html">WLength</a> &amp;&#160;</td>
          <td class="paramname"> <em>padding</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">WFlags&lt; <a class="el" href="namespaceWt.html#a5a6f4636bcc6ab3c075165d249b3a5a3">Side</a> &gt;&#160;</td>
          <td class="paramname"> <em>sides</em> = <code><a class="el" href="namespaceWt.html#a3358b8309fdb63a402efcb1a577855e8">All</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Sets padding inside the widget. </p>
<p>Setting padding has the effect of adding distance between the widget children and the border. </p>

</div>
</div>
</div>
<!--- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Namespaces</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Enumerator</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<hr size="1"><address style="text-align: right; margin: 3px"><small>
Generated on Tue Nov 30 2010 for <a href="http://www.webtoolkit.eu/wt">the
C++ Web Toolkit (Wt)</a> by&nbsp;<a
href="http://www.doxygen.org/index.html"><img src="doxygen.png"
alt="doxygen" border="0" style="vertical-align: middle; display:
inline-block; height: 2em"></a> 1.7.2</small></address>
</body>
</html>
